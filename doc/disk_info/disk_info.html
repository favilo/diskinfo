<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>disk_info.disk_info API documentation</title>
<meta name="description" content="Module `disk_info`: implements class `DiskInfo`.
Peter Sulyok (C) 2022" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>disk_info.disk_info</code></h1>
</header>
<section id="section-intro">
<p>Module <code><a title="disk_info" href="index.html">disk_info</a></code>: implements class <code><a title="disk_info.disk_info.DiskInfo" href="#disk_info.disk_info.DiskInfo">DiskInfo</a></code>.
Peter Sulyok (C) 2022</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Module `disk_info`: implements class `DiskInfo`.
    Peter Sulyok (C) 2022
&#34;&#34;&#34;
import os
from typing import List
from disk_info.disk import Disk, DiskType


class DiskInfo:
    &#34;&#34;&#34; DisksInfo class implementation.&#34;&#34;&#34;

    __disk_list: List[Disk]           # List of discovered disks.

    def __init__(self):
        &#34;&#34;&#34;At class initialization time all existing disks will be discovered in the system. After this,
        the number of identified disk can be queried with method `get_disk_number()` and the list of the identified
        disks can be also queried with method `get_disk_list()`. In both cases disk type filters can be
        applied to query only the subset of the discovered disks.&#34;&#34;&#34;

        # Initialize class variables.
        self.__disk_list = []

        # Iterate on list of block devices.
        for file_name in os.listdir(&#39;/sys/block&#39;):
            new_disk = Disk(disk_name=file_name)
            self.__disk_list.append(new_disk)

    def get_disk_number(self, included: set = None, excluded: set = None) -&gt; int:
        &#34;&#34;&#34;Returns the number of the disks. The caller can specify inclusive and exclusice filters for disk types.
        If no filters are specified then the default behaviour is to include all disk types and to exclude nothing.

        Args:
            included (set): filter set for included disk types
            excluded (set): filter set for excluded disk types
        Returns:
            int: number of the (filtered) disks
        Raises:
            ValueError: if there are common disk types on included and excluded filter sets
        Example:
            A code example about using filters: it counts the number of SSDs excluding NVME disks.

            &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
            &gt;&gt;&gt; di = DiskInfo()
            &gt;&gt;&gt; n = di.get_disk_number(included={DiskType.SSD}, excluded={DiskType.NVME})
            &gt;&gt;&gt; print(f&#34;Number of SSDs: {n}&#34;)
            Number of SSDs: 3
        &#34;&#34;&#34;
        disk_number: int    # Number of disk counted

        # Set default filters if not specified.
        if not included:
            included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
        if not excluded:
            excluded = set()

        # Check invalid filters.
        if included.intersection(excluded):
            raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

        # Count number of disks based on the specified filters.
        disk_number = 0
        for disk in self.__disk_list:
            disk_type = disk.get_type()
            if disk_type in included and disk_type not in excluded:
                disk_number += 1

        return disk_number

    def get_disk_list(self, included: set = None, excluded: set = None, sorting: bool = False,
                      rev_order: bool = False) -&gt; List[Disk]:
        &#34;&#34;&#34;Returns the list of identified disks. The caller can specify inclusive and exclusice filters for disk types.
        If no filters are specified the default behaviour is to include all disk types and to exclude nothing.
        The list can be sorted based on the disk `name` in alphabetical order. Caller can also request sorting
        in reverse order.

        Args:
            included (set): filter set for included disk types
            excluded (set): filter set for excluded disk types
            sorting (bool): disk list will be sorted based on `name` string
            rev_order (bool): sorting in reverse order
        Returns:
            List[Disk]: list of the (filtered) disks
        Raises:
            ValueError: if there are common disk types on included and excluded filter sets
        Example:
            A code example about using filters and sorting: it will list the device path of the sorted list
            of the HDDs:

            &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
            &gt;&gt;&gt; di = DiskInfo()
            &gt;&gt;&gt; disks = di.get_disk_list(included={DiskType.HDD}, sorting=True)
            &gt;&gt;&gt; for d in disks:
            ...     print(d.get_path())
            ...
            /dev/sda
            /dev/sdb
            /dev/sdc
        &#34;&#34;&#34;
        result: List[Disk] = []

        # Set default filters if not specified.
        if not included:
            included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
        if not excluded:
            excluded = set()

        # Check invalid filters.
        if included.intersection(excluded):
            raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

        # Collect selected disks based on the specified filters.
        for disk in self.__disk_list:
            disk_type = disk.get_type()
            if disk_type in included and disk_type not in excluded:
                result.append(disk)

        # Sort the result list if needed.
        if sorting:
            result.sort(reverse=rev_order)

        return result

    def __contains__(self, item):
        &#34;&#34;&#34;Returns True if a specified disk is in the discovered list of disk otherwise False.&#34;&#34;&#34;

        # Check identified list of disks if the specified disk can be found.
        for disk in self.__disk_list:
            if item.get_serial() == disk.get_serial():
                return True
        return False


# End</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="disk_info.disk_info.DiskInfo"><code class="flex name class">
<span>class <span class="ident">DiskInfo</span></span>
</code></dt>
<dd>
<div class="desc"><p>DisksInfo class implementation.</p>
<p>At class initialization time all existing disks will be discovered in the system. After this,
the number of identified disk can be queried with method <code>get_disk_number()</code> and the list of the identified
disks can be also queried with method <code>get_disk_list()</code>. In both cases disk type filters can be
applied to query only the subset of the discovered disks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DiskInfo:
    &#34;&#34;&#34; DisksInfo class implementation.&#34;&#34;&#34;

    __disk_list: List[Disk]           # List of discovered disks.

    def __init__(self):
        &#34;&#34;&#34;At class initialization time all existing disks will be discovered in the system. After this,
        the number of identified disk can be queried with method `get_disk_number()` and the list of the identified
        disks can be also queried with method `get_disk_list()`. In both cases disk type filters can be
        applied to query only the subset of the discovered disks.&#34;&#34;&#34;

        # Initialize class variables.
        self.__disk_list = []

        # Iterate on list of block devices.
        for file_name in os.listdir(&#39;/sys/block&#39;):
            new_disk = Disk(disk_name=file_name)
            self.__disk_list.append(new_disk)

    def get_disk_number(self, included: set = None, excluded: set = None) -&gt; int:
        &#34;&#34;&#34;Returns the number of the disks. The caller can specify inclusive and exclusice filters for disk types.
        If no filters are specified then the default behaviour is to include all disk types and to exclude nothing.

        Args:
            included (set): filter set for included disk types
            excluded (set): filter set for excluded disk types
        Returns:
            int: number of the (filtered) disks
        Raises:
            ValueError: if there are common disk types on included and excluded filter sets
        Example:
            A code example about using filters: it counts the number of SSDs excluding NVME disks.

            &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
            &gt;&gt;&gt; di = DiskInfo()
            &gt;&gt;&gt; n = di.get_disk_number(included={DiskType.SSD}, excluded={DiskType.NVME})
            &gt;&gt;&gt; print(f&#34;Number of SSDs: {n}&#34;)
            Number of SSDs: 3
        &#34;&#34;&#34;
        disk_number: int    # Number of disk counted

        # Set default filters if not specified.
        if not included:
            included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
        if not excluded:
            excluded = set()

        # Check invalid filters.
        if included.intersection(excluded):
            raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

        # Count number of disks based on the specified filters.
        disk_number = 0
        for disk in self.__disk_list:
            disk_type = disk.get_type()
            if disk_type in included and disk_type not in excluded:
                disk_number += 1

        return disk_number

    def get_disk_list(self, included: set = None, excluded: set = None, sorting: bool = False,
                      rev_order: bool = False) -&gt; List[Disk]:
        &#34;&#34;&#34;Returns the list of identified disks. The caller can specify inclusive and exclusice filters for disk types.
        If no filters are specified the default behaviour is to include all disk types and to exclude nothing.
        The list can be sorted based on the disk `name` in alphabetical order. Caller can also request sorting
        in reverse order.

        Args:
            included (set): filter set for included disk types
            excluded (set): filter set for excluded disk types
            sorting (bool): disk list will be sorted based on `name` string
            rev_order (bool): sorting in reverse order
        Returns:
            List[Disk]: list of the (filtered) disks
        Raises:
            ValueError: if there are common disk types on included and excluded filter sets
        Example:
            A code example about using filters and sorting: it will list the device path of the sorted list
            of the HDDs:

            &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
            &gt;&gt;&gt; di = DiskInfo()
            &gt;&gt;&gt; disks = di.get_disk_list(included={DiskType.HDD}, sorting=True)
            &gt;&gt;&gt; for d in disks:
            ...     print(d.get_path())
            ...
            /dev/sda
            /dev/sdb
            /dev/sdc
        &#34;&#34;&#34;
        result: List[Disk] = []

        # Set default filters if not specified.
        if not included:
            included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
        if not excluded:
            excluded = set()

        # Check invalid filters.
        if included.intersection(excluded):
            raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

        # Collect selected disks based on the specified filters.
        for disk in self.__disk_list:
            disk_type = disk.get_type()
            if disk_type in included and disk_type not in excluded:
                result.append(disk)

        # Sort the result list if needed.
        if sorting:
            result.sort(reverse=rev_order)

        return result

    def __contains__(self, item):
        &#34;&#34;&#34;Returns True if a specified disk is in the discovered list of disk otherwise False.&#34;&#34;&#34;

        # Check identified list of disks if the specified disk can be found.
        for disk in self.__disk_list:
            if item.get_serial() == disk.get_serial():
                return True
        return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="disk_info.disk_info.DiskInfo.get_disk_list"><code class="name flex">
<span>def <span class="ident">get_disk_list</span></span>(<span>self, included: set = None, excluded: set = None, sorting: bool = False, rev_order: bool = False) ‑> List[<a title="disk_info.disk.Disk" href="disk.html#disk_info.disk.Disk">Disk</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of identified disks. The caller can specify inclusive and exclusice filters for disk types.
If no filters are specified the default behaviour is to include all disk types and to exclude nothing.
The list can be sorted based on the disk <code>name</code> in alphabetical order. Caller can also request sorting
in reverse order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>included</code></strong> :&ensp;<code>set</code></dt>
<dd>filter set for included disk types</dd>
<dt><strong><code>excluded</code></strong> :&ensp;<code>set</code></dt>
<dd>filter set for excluded disk types</dd>
<dt><strong><code>sorting</code></strong> :&ensp;<code>bool</code></dt>
<dd>disk list will be sorted based on <code>name</code> string</dd>
<dt><strong><code>rev_order</code></strong> :&ensp;<code>bool</code></dt>
<dd>sorting in reverse order</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Disk]</code></dt>
<dd>list of the (filtered) disks</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if there are common disk types on included and excluded filter sets</dd>
</dl>
<h2 id="example">Example</h2>
<p>A code example about using filters and sorting: it will list the device path of the sorted list
of the HDDs:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from disk_info import DiskType, DiskInfo
&gt;&gt;&gt; di = DiskInfo()
&gt;&gt;&gt; disks = di.get_disk_list(included={DiskType.HDD}, sorting=True)
&gt;&gt;&gt; for d in disks:
...     print(d.get_path())
...
/dev/sda
/dev/sdb
/dev/sdc
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_disk_list(self, included: set = None, excluded: set = None, sorting: bool = False,
                  rev_order: bool = False) -&gt; List[Disk]:
    &#34;&#34;&#34;Returns the list of identified disks. The caller can specify inclusive and exclusice filters for disk types.
    If no filters are specified the default behaviour is to include all disk types and to exclude nothing.
    The list can be sorted based on the disk `name` in alphabetical order. Caller can also request sorting
    in reverse order.

    Args:
        included (set): filter set for included disk types
        excluded (set): filter set for excluded disk types
        sorting (bool): disk list will be sorted based on `name` string
        rev_order (bool): sorting in reverse order
    Returns:
        List[Disk]: list of the (filtered) disks
    Raises:
        ValueError: if there are common disk types on included and excluded filter sets
    Example:
        A code example about using filters and sorting: it will list the device path of the sorted list
        of the HDDs:

        &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
        &gt;&gt;&gt; di = DiskInfo()
        &gt;&gt;&gt; disks = di.get_disk_list(included={DiskType.HDD}, sorting=True)
        &gt;&gt;&gt; for d in disks:
        ...     print(d.get_path())
        ...
        /dev/sda
        /dev/sdb
        /dev/sdc
    &#34;&#34;&#34;
    result: List[Disk] = []

    # Set default filters if not specified.
    if not included:
        included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
    if not excluded:
        excluded = set()

    # Check invalid filters.
    if included.intersection(excluded):
        raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

    # Collect selected disks based on the specified filters.
    for disk in self.__disk_list:
        disk_type = disk.get_type()
        if disk_type in included and disk_type not in excluded:
            result.append(disk)

    # Sort the result list if needed.
    if sorting:
        result.sort(reverse=rev_order)

    return result</code></pre>
</details>
</dd>
<dt id="disk_info.disk_info.DiskInfo.get_disk_number"><code class="name flex">
<span>def <span class="ident">get_disk_number</span></span>(<span>self, included: set = None, excluded: set = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of the disks. The caller can specify inclusive and exclusice filters for disk types.
If no filters are specified then the default behaviour is to include all disk types and to exclude nothing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>included</code></strong> :&ensp;<code>set</code></dt>
<dd>filter set for included disk types</dd>
<dt><strong><code>excluded</code></strong> :&ensp;<code>set</code></dt>
<dd>filter set for excluded disk types</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>number of the (filtered) disks</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if there are common disk types on included and excluded filter sets</dd>
</dl>
<h2 id="example">Example</h2>
<p>A code example about using filters: it counts the number of SSDs excluding NVME disks.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from disk_info import DiskType, DiskInfo
&gt;&gt;&gt; di = DiskInfo()
&gt;&gt;&gt; n = di.get_disk_number(included={DiskType.SSD}, excluded={DiskType.NVME})
&gt;&gt;&gt; print(f&quot;Number of SSDs: {n}&quot;)
Number of SSDs: 3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_disk_number(self, included: set = None, excluded: set = None) -&gt; int:
    &#34;&#34;&#34;Returns the number of the disks. The caller can specify inclusive and exclusice filters for disk types.
    If no filters are specified then the default behaviour is to include all disk types and to exclude nothing.

    Args:
        included (set): filter set for included disk types
        excluded (set): filter set for excluded disk types
    Returns:
        int: number of the (filtered) disks
    Raises:
        ValueError: if there are common disk types on included and excluded filter sets
    Example:
        A code example about using filters: it counts the number of SSDs excluding NVME disks.

        &gt;&gt;&gt; from disk_info import DiskType, DiskInfo
        &gt;&gt;&gt; di = DiskInfo()
        &gt;&gt;&gt; n = di.get_disk_number(included={DiskType.SSD}, excluded={DiskType.NVME})
        &gt;&gt;&gt; print(f&#34;Number of SSDs: {n}&#34;)
        Number of SSDs: 3
    &#34;&#34;&#34;
    disk_number: int    # Number of disk counted

    # Set default filters if not specified.
    if not included:
        included = {DiskType.HDD, DiskType.SSD, DiskType.NVME}
    if not excluded:
        excluded = set()

    # Check invalid filters.
    if included.intersection(excluded):
        raise ValueError(&#34;Parameter error: same value on included and excluded list.&#34;)

    # Count number of disks based on the specified filters.
    disk_number = 0
    for disk in self.__disk_list:
        disk_type = disk.get_type()
        if disk_type in included and disk_type not in excluded:
            disk_number += 1

    return disk_number</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="disk_info" href="index.html">disk_info</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="disk_info.disk_info.DiskInfo" href="#disk_info.disk_info.DiskInfo">DiskInfo</a></code></h4>
<ul class="">
<li><code><a title="disk_info.disk_info.DiskInfo.get_disk_list" href="#disk_info.disk_info.DiskInfo.get_disk_list">get_disk_list</a></code></li>
<li><code><a title="disk_info.disk_info.DiskInfo.get_disk_number" href="#disk_info.disk_info.DiskInfo.get_disk_number">get_disk_number</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>