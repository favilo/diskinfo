<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>disk_info.disk API documentation</title>
<meta name="description" content="Module `disk`: implements classes `DiskType` and `Disk`.
Peter Sulyok (C) 2022" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>disk_info.disk</code></h1>
</header>
<section id="section-intro">
<p>Module <code>disk</code>: implements classes <code><a title="disk_info.disk.DiskType" href="#disk_info.disk.DiskType">DiskType</a></code> and <code><a title="disk_info.disk.Disk" href="#disk_info.disk.Disk">Disk</a></code>.
Peter Sulyok (C) 2022</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Module `disk`: implements classes `DiskType` and `Disk`.
    Peter Sulyok (C) 2022
&#34;&#34;&#34;
import os
from typing import List, Tuple


class DiskType:
    &#34;&#34;&#34;Constant values for disk types and for their names.&#34;&#34;&#34;
    HDD = 1
    &#34;&#34;&#34;Hard disk type.&#34;&#34;&#34;
    SSD = 2
    &#34;&#34;&#34;SSD disk type.&#34;&#34;&#34;
    NVME = 4
    &#34;&#34;&#34;NVME disk type.&#34;&#34;&#34;
    HDD_STR = &#34;HDD&#34;
    &#34;&#34;&#34;Hard disk type name.&#34;&#34;&#34;
    SSD_STR = &#34;SSD&#34;
    &#34;&#34;&#34;SSD disk type name.&#34;&#34;&#34;
    NVME_STR = &#34;NVME&#34;
    &#34;&#34;&#34;NVME disk type name.&#34;&#34;&#34;


class Disk:
    &#34;&#34;&#34;Disk class implementation.&#34;&#34;&#34;
    __name: str                         # Disk name (e.g. sda)
    __path: str                         # Disk path (e.g. /dev/sda)
    __byid_path: List[str]              # Disk by-byid paths (e.g. /dev/disk/by-byid/ata-WDC_WD80FLAX...)
    __bypath_path: List[str]            # Disk by-path paths (e.g. /dev/disk/by-path/pci-0000:00:17.0-ata-1)
    __wwn: str                          # Disk WWN byid
    __dev_id: str                       # Disk device id (e.g. 8:0)
    __model: str                        # Disk model name
    __serial_number: str                # Disk serial number
    __firmware: str                     # Disk firmware
    __type: int                         # Disk type (HDD, SSD or NVME)
    __size: int                         # Disk size (number of 512-byte blocks)
    __physical_block_size: int          # Disk physical block size
    __logical_block_size: int           # Disk logical block size
    __part_table_type: str              # Disk partition table type
    __part_table_uuid: str              # Disk partition table UUID
    __device_hwmon_path: str            # Path of the hwmon temperature file

    def __init__(self, disk_name: str = None, byid_name: str = None, bypath_name: str = None) -&gt; None:
        &#34;&#34;&#34;The class can be initialized with specifying one unique identifier of the disk. Based on this identifier
        the adequate disk information will be collected  (from `/sys` and `udev` system data) and stored in the class.
        One of the input parameters MUST be specified otherwise ValueError exception will be raised. During the class
        initialization the disk will not be directly accessed, so its power state will not be changed (e.g. will not
        be awakened from a `STANDBY` state).

        Args:
            disk_name (str): disk name (e.g. `sda` or `nvme0n1`) located in directory `/dev/`.
            byid_name (str): by-id name of the disk (e.g. `ata-WDC_WD320GLAX-68UNT16_A9HM3FTY`) located in
                             directory `/dev/disk/by-id/`.
            bypath_name (str): by-path name of the disk (e.g. `pci-0000:00:17.0-ata-1`) located in
                               directory `/dev/disk/by-path/`.

        Raises:
            ValueError: in case of missing or invalid parameters
            RuntimeError: in case of any system error

        Example:
            A simple example of use:

            &gt;&gt;&gt; from disk_info import Disk
            &gt;&gt;&gt; d = Disk(&#34;sda&#34;)
            &gt;&gt;&gt; d.get_path()
            &#39;/dev/sda&#39;
            &gt;&gt;&gt; d.get_serial()
            &#39;S3D2NY0J819210S&#39;
         &#34;&#34;&#34;
        # Identify disk name and path.
        if disk_name:
            # Save disk name and check device path.
            self.__name = disk_name
            self.__path = &#34;/dev/&#34; + disk_name
        elif byid_name:
            self.__name = os.path.basename(os.readlink(&#34;/dev/disk/by-id/&#34; + byid_name))
            self.__path = &#34;/dev/&#34; + self.__name
        elif bypath_name:
            self.__name = os.path.basename(os.readlink(&#34;/dev/disk/by-path/&#34; + bypath_name))
            self.__path = &#34;/dev/&#34; + self.__name
        else:
            raise ValueError(&#34;Missing initializer parameter, Disk() class cannot be initialized.&#34;)

        # Check the existence of disk name in /dev and /sys/block folders.
        if not os.path.exists(self.__path):
            raise ValueError(&#34;Disk path (&#34; + self.__path + &#34;) does not exist!&#34;)
        path = &#34;/sys/block/&#34; + self.__name
        if not os.path.exists(path):
            raise ValueError(&#34;Disk path (&#34; + path + &#34;) does not exist!&#34;)

        # Determine disk type (HDD, SSD, NVME)
        path = &#34;/sys/block/&#34; + self.__name + &#34;/queue/rotational&#34;
        result = self._read_file(path)
        if result == &#34;1&#34;:
            self.__type = DiskType.HDD
        elif result == &#34;0&#34;:
            self.__type = DiskType.SSD
        else:
            raise RuntimeError(&#34;Disk type cannot be determined based on this value (&#34; + path + &#34;=&#34; + result + &#34;).&#34;)
        if &#34;nvme&#34; in self.__name:
            self.__type = DiskType.NVME

        # Read attributes from /sys filesystem and from udev.
        self.__size = int(self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/size&#34;))
        self.__model = self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/device/model&#34;)
        self.__dev_id = self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/dev&#34;)
        self.__physical_block_size = int(self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/queue/physical_block_size&#34;))
        self.__logical_block_size = int(self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/queue/logical_block_size&#34;))
        self.__serial_number = self._read_udev_property(&#34;ID_SERIAL_SHORT=&#34;)
        self.__firmware = self._read_udev_property(&#34;ID_REVISION=&#34;)
        self.__wwn = self._read_udev_property(&#34;ID_WWN=&#34;)
        self.__part_table_type = self._read_udev_property(&#34;ID_PART_TABLE_TYPE=&#34;)
        self.__part_table_uuid = self._read_udev_property(&#34;ID_PART_TABLE_UUID=&#34;)
        model = self._read_udev_property(&#34;ID_MODEL_ENC=&#34;)
        if model:
            self.__model = model

        # Read `/dev/disk/by-byid/` path elements from udev and check their existence.
        self.__byid_path = self._read_udev_path(True)
        for file_name in self.__byid_path:
            if not os.path.exists(file_name):
                raise RuntimeError(&#34;Disk by-id path (&#34; + file_name + &#34;) does not exist!&#34;)

        # Read `/dev/disk/by-path/` path elements from udev and check their existence.
        self.__bypath_path = self._read_udev_path(False)
        for file_name in self.__bypath_path:
            if not os.path.exists(file_name):
                raise RuntimeError(&#34;Disk by-path path (&#34; + file_name + &#34;) does not exist!&#34;)

    def get_name(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk name.&#34;&#34;&#34;
        return self.__name

    def get_path(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk path. Please note this path is not persistent.&#34;&#34;&#34;
        return self.__path

    def get_byid_path(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-byid/...` form.
        The result could be one or more path elements.&#34;&#34;&#34;
        return self.__byid_path

    def get_bypath_path(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-path/...` form.
        The result could be one or more path elements.&#34;&#34;&#34;
        return self.__bypath_path

    def get_wwn(self) -&gt; str:
        &#34;&#34;&#34;Returns the WWN name of the disk. Read more about
        [WWN names here](https://en.wikipedia.org/wiki/World_Wide_Name).&#34;&#34;&#34;
        return self.__wwn

    def get_dev_id(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk device id.&#34;&#34;&#34;
        return self.__dev_id

    def get_model(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk model.&#34;&#34;&#34;
        return self.__model

    def get_serial(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk serial number.&#34;&#34;&#34;
        return self.__serial_number

    def get_firmware(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk firmware.&#34;&#34;&#34;
        return self.__firmware

    def get_type(self) -&gt; int:
        &#34;&#34;&#34;Returns the type of the disk.&#34;&#34;&#34;
        return self.__type

    def get_type_str(self) -&gt; str:
        &#34;&#34;&#34;Returns the name of the disk type.&#34;&#34;&#34;
        if self.is_nvme():
            return DiskType.NVME_STR
        if self.is_ssd():
            return DiskType.SSD_STR
        return DiskType.HDD_STR

    def is_ssd(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the disk type is SSD, otherwise False.&#34;&#34;&#34;
        return bool(self.__type == DiskType.SSD)

    def is_nvme(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the disk type is NVME, otherwise False.&#34;&#34;&#34;
        return bool(self.__type == DiskType.NVME)

    def is_hdd(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the disk type is HDD, otherwise False.&#34;&#34;&#34;
        return bool(self.__type == DiskType.HDD)

    def get_size(self) -&gt; int:
        &#34;&#34;&#34;Returns the size of the disk in 512-byte units.&#34;&#34;&#34;
        return self.__size

    def get_size_in_hrf(self, units: int = 0) -&gt; Tuple[float, str]:
        &#34;&#34;&#34;Returns the size of the disk in a human-readable form (e.g. &#34;1 TB&#34;).

        Args:
            units (int): unit system will be used in result (0-metric units (default), 1 - IEC units,
                         2-legacy units). Read more about [units here](https://en.wikipedia.org/wiki/Byte).

        Returns:
            Tuple[float, str]: size of the disk, proper unit
        &#34;&#34;&#34;
        metric_units: List[str] = [&#34;B&#34;, &#34;kB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
        iec_units: List[str] = [&#34;B&#34;, &#34;KiB&#34;, &#34;MiB&#34;, &#34;GiB&#34;, &#34;TiB&#34;, &#34;PiB&#34;, &#34;EiB&#34;]
        legacy_units: List[str] = [&#34;B&#34;, &#34;KB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
        divider: int    # Divider for the specified unit.
        size: float     # Result size
        unit: str       # Result unit
        i: int = 0      # Unit index

        # Set up the proper divider.
        if units == 0:
            divider = 1000
        elif units == 1:
            divider = 1024
        else:
            divider = 1024

        # Calculate the proper disk size.
        size = self.__size * 512
        number_of_units = len(metric_units)
        for i in range(number_of_units):
            if size &lt; divider:
                break
            size /= divider

        # Identify the proper unit for the calculated size.
        if units == 0:
            unit = metric_units[i]
        elif units == 1:
            unit = iec_units[i]
        else:
            unit = legacy_units[i]

        return size, unit

    def get_physical_block_size(self) -&gt; int:
        &#34;&#34;&#34;Returns the physical block size in bytes.&#34;&#34;&#34;
        return self.__physical_block_size

    def get_logical_block_size(self) -&gt; int:
        &#34;&#34;&#34;Returns the logical block size in bytes.&#34;&#34;&#34;
        return self.__logical_block_size

    def get_partition_table_type(self) -&gt; str:
        &#34;&#34;&#34;Returns the type of the partition table.&#34;&#34;&#34;
        return self.__part_table_type

    def get_partition_table_uuid(self) -&gt; str:
        &#34;&#34;&#34;Returns the UUID of the partition table.&#34;&#34;&#34;
        return self.__part_table_uuid

    @staticmethod
    def _read_file(path) -&gt; str:
        &#34;&#34;&#34;Reads the text content of the specified file. The function will hide IOError and FileNotFound exceptions
         during the file operation. The result string will be decoded (UTF-8) and stripped.

        Args:
            path (str): file path

        Returns:
            str: file content text
        &#34;&#34;&#34;
        result: str = &#34;&#34;
        try:
            with open(path, &#34;rt&#34;, encoding=&#34;UTF-8&#34;) as file:
                result = file.read()
        except (IOError, FileNotFoundError):
            pass
        return result.strip()

    def _read_udev_property(self, udev_property: str) -&gt; str:
        &#34;&#34;&#34;Reads a property from udev data file belonging to the disk (/run/udev/data/b?:?).
        It will hide IOError and FileNotFound exceptions during the file operation. The result string
        will be decoded and stripped.

        Args:
            udev_property (str): udev property string

        Returns:
            str: value of the property
        &#34;&#34;&#34;
        file_content: List[str] = []
        result: str = &#34;&#34;

        # Read proper udev data file.
        try:
            path = &#34;/run/udev/data/b&#34; + self.__dev_id
            with open(path, &#34;rt&#34;, encoding=&#34;unicode_escape&#34;) as file:
                file_content = file.read().splitlines()
        except (IOError, FileNotFoundError):
            pass

        # Find the specified udev_property and copy its value.
        for lines in file_content:
            pos = lines.find(udev_property)
            if pos != -1:
                result = lines[pos+len(udev_property):]

        return result.strip()

    def _read_udev_path(self, byid: bool) -&gt; List[str]:
        &#34;&#34;&#34;Reads one or more path elements from udev data file belonging to the disk (/run/udev/data/b?:?).
        It will hide any IO exception during the file operation.

        Args:
            byid (bool):
                True: `by-id` path elements will be loaded
                False: `by-path` path elements will be loaded
        Returns:
            List[str]: path elements
        &#34;&#34;&#34;
        path: str
        file_content: List[str] = []
        result: List[str] = []
        udev_property: str

        # Read proper udev data file.
        try:
            path = &#34;/run/udev/data/b&#34; + self.__dev_id
            with open(path, &#34;rt&#34;, encoding=&#34;UTF-8&#34;) as file:
                file_content = file.read().splitlines()
        except (IOError, FileNotFoundError):
            pass

        # Find the specified path elements and collect their value.
        if byid:
            udev_property = &#34;disk/by-id/&#34;
        else:
            udev_property = &#34;disk/by-path/&#34;
        for lines in file_content:
            pos = lines.find(udev_property)
            if pos != -1:
                result.append(&#34;/dev/&#34; + lines[pos:].strip())

        return result

    def __gt__(self, other) -&gt; bool:
        &#34;&#34;&#34;Implementation of &#39;&gt;&#39; operator for Disk class.&#34;&#34;&#34;
        return bool(self.__name &gt; other.__name)

    def __lt__(self, other) -&gt; bool:
        &#34;&#34;&#34;Implementation of &#39;&lt;&#39; operator for Disk class.&#34;&#34;&#34;
        return bool(self.__name &lt; other.__name)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Implementation of &#39;==&#39; operator for Disk class.&#34;&#34;&#34;
        return bool(self.__name == other.__name)

# End.</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="disk_info.disk.Disk"><code class="flex name class">
<span>class <span class="ident">Disk</span></span>
<span>(</span><span>disk_name: str = None, byid_name: str = None, bypath_name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Disk class implementation.</p>
<p>The class can be initialized with specifying one unique identifier of the disk. Based on this identifier
the adequate disk information will be collected
(from <code>/sys</code> and <code>udev</code> system data) and stored in the class.
One of the input parameters MUST be specified otherwise ValueError exception will be raised. During the class
initialization the disk will not be directly accessed, so its power state will not be changed (e.g. will not
be awakened from a <code>STANDBY</code> state).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>disk_name</code></strong> :&ensp;<code>str</code></dt>
<dd>disk name (e.g. <code>sda</code> or <code>nvme0n1</code>) located in directory <code>/dev/</code>.</dd>
<dt><strong><code>byid_name</code></strong> :&ensp;<code>str</code></dt>
<dd>by-id name of the disk (e.g. <code>ata-WDC_WD320GLAX-68UNT16_A9HM3FTY</code>) located in
directory <code>/dev/disk/by-id/</code>.</dd>
<dt><strong><code>bypath_name</code></strong> :&ensp;<code>str</code></dt>
<dd>by-path name of the disk (e.g. <code>pci-0000:00:17.0-ata-1</code>) located in
directory <code>/dev/disk/by-path/</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>in case of missing or invalid parameters</dd>
<dt><code>RuntimeError</code></dt>
<dd>in case of any system error</dd>
</dl>
<h2 id="example">Example</h2>
<p>A simple example of use:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from disk_info import Disk
&gt;&gt;&gt; d = Disk(&quot;sda&quot;)
&gt;&gt;&gt; d.get_path()
'/dev/sda'
&gt;&gt;&gt; d.get_serial()
'S3D2NY0J819210S'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Disk:
    &#34;&#34;&#34;Disk class implementation.&#34;&#34;&#34;
    __name: str                         # Disk name (e.g. sda)
    __path: str                         # Disk path (e.g. /dev/sda)
    __byid_path: List[str]              # Disk by-byid paths (e.g. /dev/disk/by-byid/ata-WDC_WD80FLAX...)
    __bypath_path: List[str]            # Disk by-path paths (e.g. /dev/disk/by-path/pci-0000:00:17.0-ata-1)
    __wwn: str                          # Disk WWN byid
    __dev_id: str                       # Disk device id (e.g. 8:0)
    __model: str                        # Disk model name
    __serial_number: str                # Disk serial number
    __firmware: str                     # Disk firmware
    __type: int                         # Disk type (HDD, SSD or NVME)
    __size: int                         # Disk size (number of 512-byte blocks)
    __physical_block_size: int          # Disk physical block size
    __logical_block_size: int           # Disk logical block size
    __part_table_type: str              # Disk partition table type
    __part_table_uuid: str              # Disk partition table UUID
    __device_hwmon_path: str            # Path of the hwmon temperature file

    def __init__(self, disk_name: str = None, byid_name: str = None, bypath_name: str = None) -&gt; None:
        &#34;&#34;&#34;The class can be initialized with specifying one unique identifier of the disk. Based on this identifier
        the adequate disk information will be collected  (from `/sys` and `udev` system data) and stored in the class.
        One of the input parameters MUST be specified otherwise ValueError exception will be raised. During the class
        initialization the disk will not be directly accessed, so its power state will not be changed (e.g. will not
        be awakened from a `STANDBY` state).

        Args:
            disk_name (str): disk name (e.g. `sda` or `nvme0n1`) located in directory `/dev/`.
            byid_name (str): by-id name of the disk (e.g. `ata-WDC_WD320GLAX-68UNT16_A9HM3FTY`) located in
                             directory `/dev/disk/by-id/`.
            bypath_name (str): by-path name of the disk (e.g. `pci-0000:00:17.0-ata-1`) located in
                               directory `/dev/disk/by-path/`.

        Raises:
            ValueError: in case of missing or invalid parameters
            RuntimeError: in case of any system error

        Example:
            A simple example of use:

            &gt;&gt;&gt; from disk_info import Disk
            &gt;&gt;&gt; d = Disk(&#34;sda&#34;)
            &gt;&gt;&gt; d.get_path()
            &#39;/dev/sda&#39;
            &gt;&gt;&gt; d.get_serial()
            &#39;S3D2NY0J819210S&#39;
         &#34;&#34;&#34;
        # Identify disk name and path.
        if disk_name:
            # Save disk name and check device path.
            self.__name = disk_name
            self.__path = &#34;/dev/&#34; + disk_name
        elif byid_name:
            self.__name = os.path.basename(os.readlink(&#34;/dev/disk/by-id/&#34; + byid_name))
            self.__path = &#34;/dev/&#34; + self.__name
        elif bypath_name:
            self.__name = os.path.basename(os.readlink(&#34;/dev/disk/by-path/&#34; + bypath_name))
            self.__path = &#34;/dev/&#34; + self.__name
        else:
            raise ValueError(&#34;Missing initializer parameter, Disk() class cannot be initialized.&#34;)

        # Check the existence of disk name in /dev and /sys/block folders.
        if not os.path.exists(self.__path):
            raise ValueError(&#34;Disk path (&#34; + self.__path + &#34;) does not exist!&#34;)
        path = &#34;/sys/block/&#34; + self.__name
        if not os.path.exists(path):
            raise ValueError(&#34;Disk path (&#34; + path + &#34;) does not exist!&#34;)

        # Determine disk type (HDD, SSD, NVME)
        path = &#34;/sys/block/&#34; + self.__name + &#34;/queue/rotational&#34;
        result = self._read_file(path)
        if result == &#34;1&#34;:
            self.__type = DiskType.HDD
        elif result == &#34;0&#34;:
            self.__type = DiskType.SSD
        else:
            raise RuntimeError(&#34;Disk type cannot be determined based on this value (&#34; + path + &#34;=&#34; + result + &#34;).&#34;)
        if &#34;nvme&#34; in self.__name:
            self.__type = DiskType.NVME

        # Read attributes from /sys filesystem and from udev.
        self.__size = int(self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/size&#34;))
        self.__model = self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/device/model&#34;)
        self.__dev_id = self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/dev&#34;)
        self.__physical_block_size = int(self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/queue/physical_block_size&#34;))
        self.__logical_block_size = int(self._read_file(&#34;/sys/block/&#34; + self.__name + &#34;/queue/logical_block_size&#34;))
        self.__serial_number = self._read_udev_property(&#34;ID_SERIAL_SHORT=&#34;)
        self.__firmware = self._read_udev_property(&#34;ID_REVISION=&#34;)
        self.__wwn = self._read_udev_property(&#34;ID_WWN=&#34;)
        self.__part_table_type = self._read_udev_property(&#34;ID_PART_TABLE_TYPE=&#34;)
        self.__part_table_uuid = self._read_udev_property(&#34;ID_PART_TABLE_UUID=&#34;)
        model = self._read_udev_property(&#34;ID_MODEL_ENC=&#34;)
        if model:
            self.__model = model

        # Read `/dev/disk/by-byid/` path elements from udev and check their existence.
        self.__byid_path = self._read_udev_path(True)
        for file_name in self.__byid_path:
            if not os.path.exists(file_name):
                raise RuntimeError(&#34;Disk by-id path (&#34; + file_name + &#34;) does not exist!&#34;)

        # Read `/dev/disk/by-path/` path elements from udev and check their existence.
        self.__bypath_path = self._read_udev_path(False)
        for file_name in self.__bypath_path:
            if not os.path.exists(file_name):
                raise RuntimeError(&#34;Disk by-path path (&#34; + file_name + &#34;) does not exist!&#34;)

    def get_name(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk name.&#34;&#34;&#34;
        return self.__name

    def get_path(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk path. Please note this path is not persistent.&#34;&#34;&#34;
        return self.__path

    def get_byid_path(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-byid/...` form.
        The result could be one or more path elements.&#34;&#34;&#34;
        return self.__byid_path

    def get_bypath_path(self) -&gt; List[str]:
        &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-path/...` form.
        The result could be one or more path elements.&#34;&#34;&#34;
        return self.__bypath_path

    def get_wwn(self) -&gt; str:
        &#34;&#34;&#34;Returns the WWN name of the disk. Read more about
        [WWN names here](https://en.wikipedia.org/wiki/World_Wide_Name).&#34;&#34;&#34;
        return self.__wwn

    def get_dev_id(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk device id.&#34;&#34;&#34;
        return self.__dev_id

    def get_model(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk model.&#34;&#34;&#34;
        return self.__model

    def get_serial(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk serial number.&#34;&#34;&#34;
        return self.__serial_number

    def get_firmware(self) -&gt; str:
        &#34;&#34;&#34;Returns the disk firmware.&#34;&#34;&#34;
        return self.__firmware

    def get_type(self) -&gt; int:
        &#34;&#34;&#34;Returns the type of the disk.&#34;&#34;&#34;
        return self.__type

    def get_type_str(self) -&gt; str:
        &#34;&#34;&#34;Returns the name of the disk type.&#34;&#34;&#34;
        if self.is_nvme():
            return DiskType.NVME_STR
        if self.is_ssd():
            return DiskType.SSD_STR
        return DiskType.HDD_STR

    def is_ssd(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the disk type is SSD, otherwise False.&#34;&#34;&#34;
        return bool(self.__type == DiskType.SSD)

    def is_nvme(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the disk type is NVME, otherwise False.&#34;&#34;&#34;
        return bool(self.__type == DiskType.NVME)

    def is_hdd(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the disk type is HDD, otherwise False.&#34;&#34;&#34;
        return bool(self.__type == DiskType.HDD)

    def get_size(self) -&gt; int:
        &#34;&#34;&#34;Returns the size of the disk in 512-byte units.&#34;&#34;&#34;
        return self.__size

    def get_size_in_hrf(self, units: int = 0) -&gt; Tuple[float, str]:
        &#34;&#34;&#34;Returns the size of the disk in a human-readable form (e.g. &#34;1 TB&#34;).

        Args:
            units (int): unit system will be used in result (0-metric units (default), 1 - IEC units,
                         2-legacy units). Read more about [units here](https://en.wikipedia.org/wiki/Byte).

        Returns:
            Tuple[float, str]: size of the disk, proper unit
        &#34;&#34;&#34;
        metric_units: List[str] = [&#34;B&#34;, &#34;kB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
        iec_units: List[str] = [&#34;B&#34;, &#34;KiB&#34;, &#34;MiB&#34;, &#34;GiB&#34;, &#34;TiB&#34;, &#34;PiB&#34;, &#34;EiB&#34;]
        legacy_units: List[str] = [&#34;B&#34;, &#34;KB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
        divider: int    # Divider for the specified unit.
        size: float     # Result size
        unit: str       # Result unit
        i: int = 0      # Unit index

        # Set up the proper divider.
        if units == 0:
            divider = 1000
        elif units == 1:
            divider = 1024
        else:
            divider = 1024

        # Calculate the proper disk size.
        size = self.__size * 512
        number_of_units = len(metric_units)
        for i in range(number_of_units):
            if size &lt; divider:
                break
            size /= divider

        # Identify the proper unit for the calculated size.
        if units == 0:
            unit = metric_units[i]
        elif units == 1:
            unit = iec_units[i]
        else:
            unit = legacy_units[i]

        return size, unit

    def get_physical_block_size(self) -&gt; int:
        &#34;&#34;&#34;Returns the physical block size in bytes.&#34;&#34;&#34;
        return self.__physical_block_size

    def get_logical_block_size(self) -&gt; int:
        &#34;&#34;&#34;Returns the logical block size in bytes.&#34;&#34;&#34;
        return self.__logical_block_size

    def get_partition_table_type(self) -&gt; str:
        &#34;&#34;&#34;Returns the type of the partition table.&#34;&#34;&#34;
        return self.__part_table_type

    def get_partition_table_uuid(self) -&gt; str:
        &#34;&#34;&#34;Returns the UUID of the partition table.&#34;&#34;&#34;
        return self.__part_table_uuid

    @staticmethod
    def _read_file(path) -&gt; str:
        &#34;&#34;&#34;Reads the text content of the specified file. The function will hide IOError and FileNotFound exceptions
         during the file operation. The result string will be decoded (UTF-8) and stripped.

        Args:
            path (str): file path

        Returns:
            str: file content text
        &#34;&#34;&#34;
        result: str = &#34;&#34;
        try:
            with open(path, &#34;rt&#34;, encoding=&#34;UTF-8&#34;) as file:
                result = file.read()
        except (IOError, FileNotFoundError):
            pass
        return result.strip()

    def _read_udev_property(self, udev_property: str) -&gt; str:
        &#34;&#34;&#34;Reads a property from udev data file belonging to the disk (/run/udev/data/b?:?).
        It will hide IOError and FileNotFound exceptions during the file operation. The result string
        will be decoded and stripped.

        Args:
            udev_property (str): udev property string

        Returns:
            str: value of the property
        &#34;&#34;&#34;
        file_content: List[str] = []
        result: str = &#34;&#34;

        # Read proper udev data file.
        try:
            path = &#34;/run/udev/data/b&#34; + self.__dev_id
            with open(path, &#34;rt&#34;, encoding=&#34;unicode_escape&#34;) as file:
                file_content = file.read().splitlines()
        except (IOError, FileNotFoundError):
            pass

        # Find the specified udev_property and copy its value.
        for lines in file_content:
            pos = lines.find(udev_property)
            if pos != -1:
                result = lines[pos+len(udev_property):]

        return result.strip()

    def _read_udev_path(self, byid: bool) -&gt; List[str]:
        &#34;&#34;&#34;Reads one or more path elements from udev data file belonging to the disk (/run/udev/data/b?:?).
        It will hide any IO exception during the file operation.

        Args:
            byid (bool):
                True: `by-id` path elements will be loaded
                False: `by-path` path elements will be loaded
        Returns:
            List[str]: path elements
        &#34;&#34;&#34;
        path: str
        file_content: List[str] = []
        result: List[str] = []
        udev_property: str

        # Read proper udev data file.
        try:
            path = &#34;/run/udev/data/b&#34; + self.__dev_id
            with open(path, &#34;rt&#34;, encoding=&#34;UTF-8&#34;) as file:
                file_content = file.read().splitlines()
        except (IOError, FileNotFoundError):
            pass

        # Find the specified path elements and collect their value.
        if byid:
            udev_property = &#34;disk/by-id/&#34;
        else:
            udev_property = &#34;disk/by-path/&#34;
        for lines in file_content:
            pos = lines.find(udev_property)
            if pos != -1:
                result.append(&#34;/dev/&#34; + lines[pos:].strip())

        return result

    def __gt__(self, other) -&gt; bool:
        &#34;&#34;&#34;Implementation of &#39;&gt;&#39; operator for Disk class.&#34;&#34;&#34;
        return bool(self.__name &gt; other.__name)

    def __lt__(self, other) -&gt; bool:
        &#34;&#34;&#34;Implementation of &#39;&lt;&#39; operator for Disk class.&#34;&#34;&#34;
        return bool(self.__name &lt; other.__name)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Implementation of &#39;==&#39; operator for Disk class.&#34;&#34;&#34;
        return bool(self.__name == other.__name)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="disk_info.disk.Disk.get_byid_path"><code class="name flex">
<span>def <span class="ident">get_byid_path</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk path elements in a persistent <code>/dev/disk/by-byid/...</code> form.
The result could be one or more path elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_byid_path(self) -&gt; List[str]:
    &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-byid/...` form.
    The result could be one or more path elements.&#34;&#34;&#34;
    return self.__byid_path</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_bypath_path"><code class="name flex">
<span>def <span class="ident">get_bypath_path</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk path elements in a persistent <code>/dev/disk/by-path/...</code> form.
The result could be one or more path elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bypath_path(self) -&gt; List[str]:
    &#34;&#34;&#34;Returns the disk path elements in a persistent `/dev/disk/by-path/...` form.
    The result could be one or more path elements.&#34;&#34;&#34;
    return self.__bypath_path</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_dev_id"><code class="name flex">
<span>def <span class="ident">get_dev_id</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk device id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dev_id(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk device id.&#34;&#34;&#34;
    return self.__dev_id</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_firmware"><code class="name flex">
<span>def <span class="ident">get_firmware</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk firmware.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_firmware(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk firmware.&#34;&#34;&#34;
    return self.__firmware</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_logical_block_size"><code class="name flex">
<span>def <span class="ident">get_logical_block_size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the logical block size in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_logical_block_size(self) -&gt; int:
    &#34;&#34;&#34;Returns the logical block size in bytes.&#34;&#34;&#34;
    return self.__logical_block_size</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_model"><code class="name flex">
<span>def <span class="ident">get_model</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk model.&#34;&#34;&#34;
    return self.__model</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk name.&#34;&#34;&#34;
    return self.__name</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_partition_table_type"><code class="name flex">
<span>def <span class="ident">get_partition_table_type</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the type of the partition table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partition_table_type(self) -&gt; str:
    &#34;&#34;&#34;Returns the type of the partition table.&#34;&#34;&#34;
    return self.__part_table_type</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_partition_table_uuid"><code class="name flex">
<span>def <span class="ident">get_partition_table_uuid</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the UUID of the partition table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_partition_table_uuid(self) -&gt; str:
    &#34;&#34;&#34;Returns the UUID of the partition table.&#34;&#34;&#34;
    return self.__part_table_uuid</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_path"><code class="name flex">
<span>def <span class="ident">get_path</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk path. Please note this path is not persistent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk path. Please note this path is not persistent.&#34;&#34;&#34;
    return self.__path</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_physical_block_size"><code class="name flex">
<span>def <span class="ident">get_physical_block_size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the physical block size in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_physical_block_size(self) -&gt; int:
    &#34;&#34;&#34;Returns the physical block size in bytes.&#34;&#34;&#34;
    return self.__physical_block_size</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_serial"><code class="name flex">
<span>def <span class="ident">get_serial</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the disk serial number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_serial(self) -&gt; str:
    &#34;&#34;&#34;Returns the disk serial number.&#34;&#34;&#34;
    return self.__serial_number</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the size of the disk in 512-byte units.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self) -&gt; int:
    &#34;&#34;&#34;Returns the size of the disk in 512-byte units.&#34;&#34;&#34;
    return self.__size</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_size_in_hrf"><code class="name flex">
<span>def <span class="ident">get_size_in_hrf</span></span>(<span>self, units: int = 0) ‑> Tuple[float, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the size of the disk in a human-readable form (e.g. "1 TB").</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>units</code></strong> :&ensp;<code>int</code></dt>
<dd>unit system will be used in result (0-metric units (default), 1 - IEC units,
2-legacy units). Read more about <a href="https://en.wikipedia.org/wiki/Byte">units here</a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, str]</code></dt>
<dd>size of the disk, proper unit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size_in_hrf(self, units: int = 0) -&gt; Tuple[float, str]:
    &#34;&#34;&#34;Returns the size of the disk in a human-readable form (e.g. &#34;1 TB&#34;).

    Args:
        units (int): unit system will be used in result (0-metric units (default), 1 - IEC units,
                     2-legacy units). Read more about [units here](https://en.wikipedia.org/wiki/Byte).

    Returns:
        Tuple[float, str]: size of the disk, proper unit
    &#34;&#34;&#34;
    metric_units: List[str] = [&#34;B&#34;, &#34;kB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
    iec_units: List[str] = [&#34;B&#34;, &#34;KiB&#34;, &#34;MiB&#34;, &#34;GiB&#34;, &#34;TiB&#34;, &#34;PiB&#34;, &#34;EiB&#34;]
    legacy_units: List[str] = [&#34;B&#34;, &#34;KB&#34;, &#34;MB&#34;, &#34;GB&#34;, &#34;TB&#34;, &#34;PB&#34;, &#34;EB&#34;]
    divider: int    # Divider for the specified unit.
    size: float     # Result size
    unit: str       # Result unit
    i: int = 0      # Unit index

    # Set up the proper divider.
    if units == 0:
        divider = 1000
    elif units == 1:
        divider = 1024
    else:
        divider = 1024

    # Calculate the proper disk size.
    size = self.__size * 512
    number_of_units = len(metric_units)
    for i in range(number_of_units):
        if size &lt; divider:
            break
        size /= divider

    # Identify the proper unit for the calculated size.
    if units == 0:
        unit = metric_units[i]
    elif units == 1:
        unit = iec_units[i]
    else:
        unit = legacy_units[i]

    return size, unit</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_type"><code class="name flex">
<span>def <span class="ident">get_type</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the type of the disk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type(self) -&gt; int:
    &#34;&#34;&#34;Returns the type of the disk.&#34;&#34;&#34;
    return self.__type</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_type_str"><code class="name flex">
<span>def <span class="ident">get_type_str</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the disk type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_str(self) -&gt; str:
    &#34;&#34;&#34;Returns the name of the disk type.&#34;&#34;&#34;
    if self.is_nvme():
        return DiskType.NVME_STR
    if self.is_ssd():
        return DiskType.SSD_STR
    return DiskType.HDD_STR</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.get_wwn"><code class="name flex">
<span>def <span class="ident">get_wwn</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the WWN name of the disk. Read more about
<a href="https://en.wikipedia.org/wiki/World_Wide_Name">WWN names here</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wwn(self) -&gt; str:
    &#34;&#34;&#34;Returns the WWN name of the disk. Read more about
    [WWN names here](https://en.wikipedia.org/wiki/World_Wide_Name).&#34;&#34;&#34;
    return self.__wwn</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.is_hdd"><code class="name flex">
<span>def <span class="ident">is_hdd</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the disk type is HDD, otherwise False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_hdd(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the disk type is HDD, otherwise False.&#34;&#34;&#34;
    return bool(self.__type == DiskType.HDD)</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.is_nvme"><code class="name flex">
<span>def <span class="ident">is_nvme</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the disk type is NVME, otherwise False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_nvme(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the disk type is NVME, otherwise False.&#34;&#34;&#34;
    return bool(self.__type == DiskType.NVME)</code></pre>
</details>
</dd>
<dt id="disk_info.disk.Disk.is_ssd"><code class="name flex">
<span>def <span class="ident">is_ssd</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the disk type is SSD, otherwise False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ssd(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the disk type is SSD, otherwise False.&#34;&#34;&#34;
    return bool(self.__type == DiskType.SSD)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="disk_info.disk.DiskType"><code class="flex name class">
<span>class <span class="ident">DiskType</span></span>
</code></dt>
<dd>
<div class="desc"><p>Constant values for disk types and for their names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DiskType:
    &#34;&#34;&#34;Constant values for disk types and for their names.&#34;&#34;&#34;
    HDD = 1
    &#34;&#34;&#34;Hard disk type.&#34;&#34;&#34;
    SSD = 2
    &#34;&#34;&#34;SSD disk type.&#34;&#34;&#34;
    NVME = 4
    &#34;&#34;&#34;NVME disk type.&#34;&#34;&#34;
    HDD_STR = &#34;HDD&#34;
    &#34;&#34;&#34;Hard disk type name.&#34;&#34;&#34;
    SSD_STR = &#34;SSD&#34;
    &#34;&#34;&#34;SSD disk type name.&#34;&#34;&#34;
    NVME_STR = &#34;NVME&#34;
    &#34;&#34;&#34;NVME disk type name.&#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="disk_info.disk.DiskType.HDD"><code class="name">var <span class="ident">HDD</span></code></dt>
<dd>
<div class="desc"><p>Hard disk type.</p></div>
</dd>
<dt id="disk_info.disk.DiskType.HDD_STR"><code class="name">var <span class="ident">HDD_STR</span></code></dt>
<dd>
<div class="desc"><p>Hard disk type name.</p></div>
</dd>
<dt id="disk_info.disk.DiskType.NVME"><code class="name">var <span class="ident">NVME</span></code></dt>
<dd>
<div class="desc"><p>NVME disk type.</p></div>
</dd>
<dt id="disk_info.disk.DiskType.NVME_STR"><code class="name">var <span class="ident">NVME_STR</span></code></dt>
<dd>
<div class="desc"><p>NVME disk type name.</p></div>
</dd>
<dt id="disk_info.disk.DiskType.SSD"><code class="name">var <span class="ident">SSD</span></code></dt>
<dd>
<div class="desc"><p>SSD disk type.</p></div>
</dd>
<dt id="disk_info.disk.DiskType.SSD_STR"><code class="name">var <span class="ident">SSD_STR</span></code></dt>
<dd>
<div class="desc"><p>SSD disk type name.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="disk_info" href="index.html">disk_info</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="disk_info.disk.Disk" href="#disk_info.disk.Disk">Disk</a></code></h4>
<ul class="">
<li><code><a title="disk_info.disk.Disk.get_byid_path" href="#disk_info.disk.Disk.get_byid_path">get_byid_path</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_bypath_path" href="#disk_info.disk.Disk.get_bypath_path">get_bypath_path</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_dev_id" href="#disk_info.disk.Disk.get_dev_id">get_dev_id</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_firmware" href="#disk_info.disk.Disk.get_firmware">get_firmware</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_logical_block_size" href="#disk_info.disk.Disk.get_logical_block_size">get_logical_block_size</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_model" href="#disk_info.disk.Disk.get_model">get_model</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_name" href="#disk_info.disk.Disk.get_name">get_name</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_partition_table_type" href="#disk_info.disk.Disk.get_partition_table_type">get_partition_table_type</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_partition_table_uuid" href="#disk_info.disk.Disk.get_partition_table_uuid">get_partition_table_uuid</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_path" href="#disk_info.disk.Disk.get_path">get_path</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_physical_block_size" href="#disk_info.disk.Disk.get_physical_block_size">get_physical_block_size</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_serial" href="#disk_info.disk.Disk.get_serial">get_serial</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_size" href="#disk_info.disk.Disk.get_size">get_size</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_size_in_hrf" href="#disk_info.disk.Disk.get_size_in_hrf">get_size_in_hrf</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_type" href="#disk_info.disk.Disk.get_type">get_type</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_type_str" href="#disk_info.disk.Disk.get_type_str">get_type_str</a></code></li>
<li><code><a title="disk_info.disk.Disk.get_wwn" href="#disk_info.disk.Disk.get_wwn">get_wwn</a></code></li>
<li><code><a title="disk_info.disk.Disk.is_hdd" href="#disk_info.disk.Disk.is_hdd">is_hdd</a></code></li>
<li><code><a title="disk_info.disk.Disk.is_nvme" href="#disk_info.disk.Disk.is_nvme">is_nvme</a></code></li>
<li><code><a title="disk_info.disk.Disk.is_ssd" href="#disk_info.disk.Disk.is_ssd">is_ssd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="disk_info.disk.DiskType" href="#disk_info.disk.DiskType">DiskType</a></code></h4>
<ul class="two-column">
<li><code><a title="disk_info.disk.DiskType.HDD" href="#disk_info.disk.DiskType.HDD">HDD</a></code></li>
<li><code><a title="disk_info.disk.DiskType.HDD_STR" href="#disk_info.disk.DiskType.HDD_STR">HDD_STR</a></code></li>
<li><code><a title="disk_info.disk.DiskType.NVME" href="#disk_info.disk.DiskType.NVME">NVME</a></code></li>
<li><code><a title="disk_info.disk.DiskType.NVME_STR" href="#disk_info.disk.DiskType.NVME_STR">NVME_STR</a></code></li>
<li><code><a title="disk_info.disk.DiskType.SSD" href="#disk_info.disk.DiskType.SSD">SSD</a></code></li>
<li><code><a title="disk_info.disk.DiskType.SSD_STR" href="#disk_info.disk.DiskType.SSD_STR">SSD_STR</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>